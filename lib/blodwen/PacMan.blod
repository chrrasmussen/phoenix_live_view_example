import ErlangPrelude
import PhoenixLiveView
import Data.Nat
import Data.List
import Control.Pipeline
import Utils


-- BOARD

data Block = Wall | Empty

W : Block
W = Wall

E : Block
E = Empty

board : List (List Block)
board =
  [ [W, W, W, W]
  , [W, E, E, W]
  , [W, E, E, W]
  , [W, W, W, W]
  ]

rows : Nat
rows = length board

cols : Nat
cols = maybe 0 length (head' board)

indexedBoard : List (Nat, List (Nat, Block))
indexedBoard =
  zip (range 0 (minus rows 1))
    (map (zip (range 0 (minus cols 1))) board)


-- BOARD VIEW

blockSize : Double
blockSize = 25

blockType : Block -> ErlAtom
blockType Wall = MkErlAtom "wall"
blockType Empty = MkErlAtom "empty"

boardBlocks : Double -> ErlMap
boardBlocks widthFactor =
  indexedBoard
    |> concatMap (\row => map (\col => blockEntry (fst row) (fst col) (snd col)) (Builtin.snd row))
    |> fromList
  where
    blockEntry : Nat -> Nat -> Block -> (ErlTuple2 Int Int, ErlMap)
    blockEntry row col block =
      let blockData =
          Maps.empty
            |> insert (MkErlAtom "type") (blockType block)
            |> insert (MkErlAtom "x") (cast col * widthFactor)
            |> insert (MkErlAtom "y") (cast row * widthFactor)
            |> insert (MkErlAtom "width") widthFactor
      in (MkErlTuple2 (cast col) (cast row), blockData)


-- GAME

tick : Int
tick = 200

data Direction = Up | Right | Down | Left

rotation : Direction -> Int
rotation Up = -90
rotation Right = 0
rotation Down = 90
rotation Left = 180

record GameState where
  constructor MkGameState
  heading : Direction
  x : Nat
  y : Nat

arrowKeyToDirection : String -> Maybe Direction
arrowKeyToDirection "ArrowLeft" = Just Left
arrowKeyToDirection "ArrowDown" = Just Down
arrowKeyToDirection "ArrowUp" = Just Up
arrowKeyToDirection "ArrowRight" = Just Right
arrowKeyToDirection _ = Nothing


-- PHOENIX LIVE VIEW

Model : Type
Model = GameState

init : IO Model
init = pure (MkGameState Right 1 1)

update : String -> ErlTerm -> Model -> IO Model
update "keydown" params model = do
  let Just direction = erlTermToString params >>= arrowKeyToDirection
    | _ => pure model
  pure (the GameState (record { heading = direction } model))
update _ _ model = pure model

view : Model -> View
view model =
  let assigns =
      Maps.empty
        |> insert (MkErlAtom "rotation") (rotation (heading model))
        |> insert (MkErlAtom "x") (cast (x model) * blockSize)
        |> insert (MkErlAtom "y") (cast (y model) * blockSize)
        |> insert (MkErlAtom "width") blockSize
        |> insert (MkErlAtom "blocks") (boardBlocks blockSize)
  in renderTemplate "Elixir.DemoWeb.BlodwenPacmanView" "index.html" assigns

handleInfo : ErlTerm -> Model -> IO Model
handleInfo msg model = pure model

exports : ErlExports
exports =
  exportPhoenixLiveView init update view handleInfo

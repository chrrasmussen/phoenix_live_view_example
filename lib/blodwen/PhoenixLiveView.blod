module PhoenixLiveView

import ErlangPrelude

export
data Socket : Type where

Cast Socket ErlTerm where
  cast x = believe_me x

Cast ErlTerm Socket where
  cast x = believe_me x


export
renderTemplate : String -> String -> ErlMap -> ErlTerm
renderTemplate viewModule templateName assigns = unsafePerformIO $
  erlCall viewModule "render" [templateName, assigns]


export
assign : (ErlType key, ErlType value) => key -> value -> Socket -> Socket
assign key value socket = unsafePerformIO $ do
  result <- erlCall "Elixir.Phoenix.LiveView" "assign" [cast {to=ErlTerm} socket, key, value]
  pure (cast result)


export
update : (ErlType key, ErlType newValue) => key -> (ErlTerm -> newValue) -> Socket -> Socket
update key func socket = unsafePerformIO $ do
  result <- erlCall "Elixir.Phoenix.LiveView" "update" [cast {to=ErlTerm} socket, key, func]
  pure (cast result)

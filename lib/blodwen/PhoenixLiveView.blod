module PhoenixLiveView

import ErlangPrelude


-- RENDER

export
data View : Type where

viewToErlTerm : View -> ErlTerm
viewToErlTerm x = believe_me x

erlTermToView : ErlTerm -> View
erlTermToView x = believe_me x

export
renderTemplate : String -> String -> ErlMap -> View
renderTemplate viewModule templateName assigns = unsafePerformIO $ do
  term <- erlCall viewModule "render" [templateName, assigns]
  pure $ erlTermToView term


-- HELPERS

socketAssign : (ErlType key, ErlType value) => key -> value -> ErlTerm -> ErlTerm
socketAssign key value socket = unsafePerformIO $
  erlCall "Elixir.Phoenix.LiveView" "assign" [socket, key, value]

socketUpdate : (ErlType key, ErlType value) => key -> (ErlTerm -> value) -> ErlTerm -> ErlTerm
socketUpdate key func socket = unsafePerformIO $
  erlCall "Elixir.Phoenix.LiveView" "update" [socket, key, func]

socketGet : (ErlType key) => key -> ErlTerm -> Maybe ErlTerm
socketGet key socket = do
  assigns <- unsafeLookup (MkErlAtom "assigns") ErlMap (erlUnsafeCast ErlMap socket)
  unsafeLookup key ErlTerm assigns


-- LIFE-CYCLE

modelKey : ErlAtom
modelKey = MkErlAtom "blodwen_model"

mount : IO model -> ErlTerm -> ErlTerm -> IO (ErlTuple2 ErlAtom ErlTerm)
mount init session socket = do
  modelData <- init
  let newSocket = socketAssign modelKey (MkRaw modelData) socket
  pure $ MkErlTuple2 (MkErlAtom "ok") newSocket

handleEvent : (String -> ErlTerm -> model -> IO model) -> String -> ErlTerm -> ErlTerm -> IO (ErlTuple2 ErlAtom ErlTerm)
handleEvent update event unsignedParams socket = do
  let Just term = socketGet modelKey socket
  let MkRaw modelData = (erlUnsafeCast (Raw model) term)
  newModelData <- update event unsignedParams modelData
  let newSocket = socketAssign modelKey (MkRaw newModelData) socket
  pure $ MkErlTuple2 (MkErlAtom "noreply") newSocket

handleInfo : (ErlTerm -> model -> IO model) -> ErlTerm -> ErlTerm -> IO ErlTerm
handleInfo infoHandler msg socket = do
  let Just term = socketGet modelKey socket
  let MkRaw modelData = erlUnsafeCast (Raw model) term
  newModelData <- infoHandler msg modelData
  let newSocket = socketAssign modelKey (MkRaw newModelData) socket
  pure $ cast $ MkErlTuple2 (MkErlAtom "noreply") newSocket

render : (model -> View) -> ErlMap -> ErlTerm
render view assigns =
  let Just (MkRaw modelData) = unsafeLookup modelKey (Raw model) assigns
  in viewToErlTerm (view modelData)


-- EXPORT

export %inline
exportPhoenixLiveView :
  (init : IO model) ->
  (update : String -> ErlTerm -> model -> IO model) ->
  (view : model -> View) ->
  (handleInfo : ErlTerm -> model -> IO model) ->
  ErlExports
exportPhoenixLiveView init update view infoHandler =
  Fun "mount" (MkErlIO2 (mount init)) <+>
    Fun "handle_event" (MkErlIO3 (handleEvent update)) <+>
    Fun "handle_info" (MkErlIO2 (handleInfo infoHandler)) <+>
    Fun "render" (MkErlFun1 (render view))
